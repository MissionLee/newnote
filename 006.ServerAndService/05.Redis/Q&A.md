# Q&A

- redis单线程
  - 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。
- 为什么说redis能够快速执行
  - 绝大部分请求是纯粹的内存操作（非常快速）
  - 采用单线程,避免了不必要的上下文切换和竞争条件
  - 非阻塞IO - [IO多路复用](../../994.BasicKnowledge/IO多路复用.md)
    - 由于进程的执行过程是线性的(也就是顺序执行),当我们调用低速系统I/O(read,write,accept等等),进程可能阻塞,此时进程就阻塞在这个调用上,不能执行其他操作.阻塞很正常.
    - 接下来考虑这么一个问题:一个服务器进程和一个客户端进程通信,服务器端read(sockfd1,bud,bufsize),此时客户端进程没有发送数据,那么read(阻塞调用)将阻塞，直到客户端调用write(sockfd,but,size)发来数据.在一个客户和服务器通信时这没什么问题；
    - 当多个客户与服务器通信时当多个客户与服务器通信时,若服务器阻塞于其中一个客户sockfd1,当另一个客户的数据到达套接字sockfd2时,服务器不能处理,仍然阻塞在read(sockfd1,...)上;此时问题就出现了,不能及时处理另一个客户的服务,咋么办?
    - I/O多路复用来解决!
- redis的内部实现
  - 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。
- Redis关于线程安全问题
  -  redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。
- 使用Redis有哪些好处？
  - (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
  - (2) 支持丰富数据类型，支持string，list，set，sorted set，hash
  - (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
  - (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
-  Redis相比memcached有哪些优势？
    - (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
    - (2) redis的速度比memcached快很多
    - (3) redis可以持久化其数据
    - (4)Redis支持数据的备份，即master-slave模式的数据备份。
    - (5) 使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。  - Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移  - 动和请求。
    - (6）value大小：redis最大可以达到1GB，而memcache只有1MB
- Redis常见性能问题和解决方案：
    - (1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件；(Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照;AOF文件过大会影响Master重启的恢复速度)
    - (2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
    - (3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
    - (4) 尽量避免在压力很大的主库上增加从库
    - (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...；这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。
-  Redis的回收策略
    - volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    - volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    - volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    - allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
    - allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    - no-enviction（驱逐）：禁止驱逐数据
    > 注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。
    - 使用策略规则：
        - 1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru
        - 2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random